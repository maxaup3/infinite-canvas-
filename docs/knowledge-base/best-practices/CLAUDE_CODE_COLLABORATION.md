# Claude Code 协作最佳实践

## 概览

这份指南汇聚了与 Claude Code 高效协作的具体方法和技巧，基于 Infinite Canvas 项目的真实经验。

---

## 📝 1. 清晰描述问题（50% 的成功）

### ❌ 不好的描述例子

```
"图片有问题"
"这个功能不工作"
"修复 bug"
```

**问题：** 太模糊，Claude 需要反复问问题才能理解

### ✅ 好的描述例子

```
现象：
当我点击图片选中它，然后按 C 键切换编辑模式时，
鼠标轻微移动会导致图片跟随鼠标。

期望：
只有当我实际拖动图片时，它才应该移动。
轻微的鼠标移动（< 5px）不应该触发拖动。

重现步骤：
1. 在画布中放置一张图片
2. 点击图片选中它
3. 按 C 键切换到编辑模式
4. 鼠标轻微晃动
5. 观察图片跟随鼠标移动

相关文件：src/components/Canvas.tsx
```

**好处：** Claude 能准确理解问题，直接给出修复方案

---

## 🎯 2. 提供充分的上下文

### 必须包含的信息

| 信息 | 为什么重要 | 例子 |
|-----|----------|------|
| **应用类型** | 影响状态管理策略 | "这是一个 demo（每次刷新重置）" |
| **用户场景** | 影响优先级和设计 | "新手用户首次使用应用" |
| **期望行为** | Claude 才能判断是否正确 | "应该每次都显示欢迎页面" |
| **实际行为** | 帮助定位问题 | "刷新后直接进入画布，没有欢迎页" |
| **首次出现** | 是否影响已发布功能 | "一直都这样" vs "今天才出现的" |
| **相关文件** | 加快诊断速度 | "在 src/App.tsx 和 Canvas.tsx 中" |

### 上下文提供示例

**应用背景：**
```
这是一个无限画布的 AI 图片编辑工具。
用户可以上传图片，使用 AI 进行分层编辑。
应用采用 React + Konva 架构。
```

**问题背景：**
```
我们希望用户每次刷新都看到欢迎页面
（这样演示时能展示完整的新手流程）
```

**尝试过的方案：**
```
之前添加了 localStorage 保存状态，
但这导致用户刷新后直接进入画布，
跳过了欢迎页面。
```

---

## 💬 3. 及时反馈实现质量

### 反馈的三个层面

#### 层面 1: 功能正确性
```
✅ 好的反馈：
"缩放功能工作正确，但最小尺寸太小，
图片缩小到 10px 时无法看清。
建议最小高度改为 50px。"

❌ 不好的反馈：
"缩放功能坏了"
```

#### 层面 2: 用户体验
```
✅ 好的反馈：
"拖动时有轻微卡顿，特别是拖动大图片时。
是否有性能优化的空间？"

❌ 不好的反馈：
"感觉不太对"
```

#### 层面 3: 实现方案
```
✅ 好的反馈：
"这个实现效果很差。
相比之下，Konva 的内置拖动功能
在这个场景下工作得更好。
我们应该回到之前的方式。"

❌ 不好的反馈：
"实现效果很差"
```

### 及时反馈的关键

- ⏱️ **在修改完成后立即反馈**（不要等一周）
- 🎯 **指出具体的问题**（不要只说"不好"）
- 📊 **对比和参考**（"与 X 相比..."）
- 💡 **提出可能的改进**（"是否可以..."）

---

## 🤝 4. 允许 Claude 提出多个方案

### 方案对话的标准流程

**阶段 1：问题诊断**
```
你：
"我们想让欢迎页面在 demo 中每次都显示。
现在的问题是它只显示一次，之后就跳过了。
这是一个 demo（非生产应用），不需要记住用户状态。"

Claude：
→ 读取代码
→ 发现问题（localStorage 保存了状态）
→ 识别根本原因
```

**阶段 2：方案建议**
```
Claude：
"我发现了三种解决方案：

方案 A：删除 localStorage 逻辑，硬编码 false
  优点：简单快速
  缺点：如果未来需要持久化，要重新添加

方案 B：添加一个 reset 按钮，让用户手动重置
  优点：保留状态同时支持重置
  缺点：多了一个 UI 元素

方案 C：检测 URL 参数（?reset），条件性地重置
  优点：灵活，演示时加参数即可
  缺点：实现稍复杂

你觉得哪个方案最合适？"
```

**阶段 3：你选择**
```
你：
"方案 A 最简单，我们就用这个。
现在是 demo，如果未来需要改就再改。"

Claude：
"好的，我立即实现。"
```

### 何时要求多个方案

- 🤔 **实现方式多种** - 虽然有多种实现方式，但需要权衡
- ⚖️ **需要权衡取舍** - 性能 vs 代码复杂度
- 🎨 **设计空间大** - 相同功能，多种表现方式
- 🔄 **影响长期架构** - 决定会影响未来的维护

---

## 🔄 5. 充分利用版本控制

### 安全修改的三个黄金法则

#### 规则 1: 经常提交小的修改

```bash
# ✅ 好的做法：一次修改一个功能
git add src/components/Canvas.tsx
git commit -m "特性：添加滚轮缩放功能"

git add src/components/BottomDialog.tsx
git commit -m "修复：统一中文文案"

# ❌ 避免：一次修改多个独立功能
git add .
git commit -m "各种改动"
```

**好处：**
- 如果某个改动有问题，只需要回退那一个
- 提交历史清晰，易于追踪

#### 规则 2: 失败的改动可以快速回退

```bash
# 如果修改效果不好
git checkout src/components/Canvas.tsx

# 如果想回退多个提交
git revert HEAD~2..HEAD

# 如果想查看改动历史
git log -p src/components/Canvas.tsx
```

**好处：**
- 不必担心"搞坏"代码
- 可以大胆尝试新想法

#### 规则 3: 记录清晰的提交消息

```
✅ 好的提交消息：
git commit -m "修复：编辑模式变化时重置拖动状态

- 添加 useEffect 监听 editMode
- 重置 isDragging, dragStartPosRef, dragActivatedRef
- 解决用户拖动后切换模式时图片继续跟随的问题"

❌ 不好的提交消息：
git commit -m "fixed bug"
git commit -m "update"
git commit -m "修改"
```

### 版本控制工作流

```
1. 创建分支（可选但推荐）
   git checkout -b fix/drag-state-reset

2. 做出修改
   编辑 src/components/Canvas.tsx

3. 检查修改
   git diff src/components/Canvas.tsx

4. 提交修改
   git add src/components/Canvas.tsx
   git commit -m "修复：..."

5. 测试
   npm run dev
   在浏览器中测试

6. 如果有问题，回退
   git revert <commit-hash>
   或
   git checkout src/components/Canvas.tsx

7. 如果没问题，继续
   下一个修改或合并到 main 分支
```

---

## ✅ 6. 每次修改后都验证

### 三层验证清单

#### 第 1 层：编译验证
```bash
# 每次修改代码后立即运行
npx tsc --noEmit

# 输出说明：
# 无输出 = 编译成功 ✅
# 有错误 = 立即修复 ⚠️
```

#### 第 2 层：浏览器验证
```bash
# 1. 确保开发服务器运行
npm run dev

# 2. 打开浏览器（应该自动打开 http://localhost:5174）

# 3. 刷新页面（Cmd+R）

# 4. 打开开发者工具（F12）

# 5. 查看 Console 标签是否有错误

# 6. 测试修改的功能
```

#### 第 3 层：功能验证
```
修改缩放功能后的检查清单：
□ 选中图片
□ 向上滚动 → 图片放大 ✓
□ 向下滚动 → 图片缩小 ✓
□ 缩放到最小尺寸 → 停止缩小 ✓
□ 宽高比保持一致 ✓
□ 未选中的图片不缩放 ✓
□ 锁定的图片不缩放 ✓
```

---

## 📚 7. 文档和 PDF 处理

### Claude 可以读取的文档

✅ **可以处理：**
- PDF 文件（设计文档、需求说明）
- Markdown 文件
- 代码文件
- 图片文件

❌ **难以处理：**
- 非常大的 PDF（> 50MB）
- 有特殊格式的文档
- 受密码保护的文件

### 文档使用的最佳实践

#### 示例 1：分享设计文档

```
你：
"请阅读这份基于 Layer 的画布推演文档。
然后告诉我应该在哪些代码文件中实现这些功能。"

[附上 PDF 文件]

Claude：
1. 读取并解析 PDF
2. 提取核心概念
3. 分析现有代码
4. 给出具体实现建议

输出：
"根据文档，我理解了 Layer 系统的三个核心功能：
1. 图层分组 → 修改 src/types/index.ts 中的 ImageLayer
2. 批量操作 → 新增 src/utils/layerBatch.ts
3. 分层编辑 → 扩展 src/components/Canvas.tsx
"
```

#### 示例 2：对标竞品分析

```
你：
"看看这份竞品分析报告，
然后告诉我我们应该优先实现哪些功能。"

Claude：
1. 读取报告
2. 对比你当前的功能
3. 分析竞争差距
4. 给出优先级建议
```

### 最佳实践

- 📄 **不要一次分享太多文档** - 一次最多 2-3 个
- 🎯 **清晰说明需要什么** - "阅读后，告诉我..."
- 💡 **提供上下文** - "这是我们的产品方向"
- 🔗 **文档间要有关联** - 一起分享相关的多个文档

---

## 🎓 8. 学习 Claude 的工作方式

### Claude 最擅长的

✅ **代码分析和修改**
- 理解复杂的代码逻辑
- 发现潜在的 bug
- 建议重构方案

✅ **问题诊断**
- 分析根本原因
- 识别多个可能的解决方案
- 权衡各种方案的优缺点

✅ **文档理解**
- 读取和总结 PDF
- 提取关键信息
- 与代码实现对齐

✅ **最佳实践建议**
- 代码风格和结构
- 性能优化建议
- 安全性审查

### Claude 的局限性

⚠️ **实时测试**
- Claude 不能在浏览器中测试你的代码
- 你需要在浏览器中验证

⚠️ **设计决策**
- Claude 可以建议，但最终决定权在你
- 你对产品的理解比 Claude 更深

⚠️ **创意想象**
- Claude 可以列出可能性，但无法想象未来产品的样子
- 你需要提供设计方向

### 如何充分利用 Claude

```
互补的工作流：

设计师的角色：        Claude 的角色：
决策                 建议
想象                 实现
验证                 诊断
反馈                 调整

例如：
你："我想要一个玻璃态的效果"
     ↓
Claude："玻璃态通常这样实现..."
     ↓
你："是的，就是这样，但要更强的模糊效果"
     ↓
Claude："我增加了模糊半径..."
     ↓
你："完美！"
```

---

## 🚀 9. 一步步的协作流程模板

### Bug 修复流程

```
第 1 步：报告 Bug
────────────────
你：描述现象、期望、重现步骤

第 2 步：诊断
────────────────
Claude：
- 读取相关代码
- 提出问题假设
- 确认根本原因

第 3 步：方案
────────────────
Claude：
- 列出可能的修复方案
- 分析优缺点
- 推荐最优方案

你：
- 选择方案或提出改进

第 4 步：实现
────────────────
Claude：
- 编写修复代码
- 运行 TypeScript 检查

第 5 步：验证
────────────────
你：
- 在浏览器中测试
- 确认 bug 是否修复
- 检查是否引入新 bug

第 6 步：提交
────────────────
如果满意：
  git add && git commit -m "修复：..."

如果不满意：
  git checkout file（回退）
  回到第 3 步，尝试其他方案
```

### 新功能开发流程

```
第 1 步：需求
────────────────
你：清晰描述功能需求和设计

第 2 步：方案
────────────────
Claude：
- 分析需求
- 列出实现策略
- 建议在哪些文件中修改

你：审查并确认

第 3 步：分析
────────────────
Claude：
- 读取现有代码
- 理解数据流
- 提出集成方案

第 4 步：实现
────────────────
Claude：
- 分模块实现
- 每个模块后验证编译
- 最后整体测试

第 5 步：测试
────────────────
你：
- 逐个测试功能点
- 测试边界情况
- 测试与其他功能的交互

第 6 步：优化
────────────────
如果有性能问题：
  Claude：建议优化方案
  你：选择是否优化

如果有 UX 问题：
  Claude：建议改进
  你：选择是否改进

第 7 步：提交
────────────────
git add && git commit -m "特性：..."
```

---

## 💡 10. 常见陷阱和避免方法

### 陷阱 1：模糊的问题描述

```
❌ "这个功能有问题"
✅ "当我点击 X 然后做 Y 时，
    应该出现 Z，但实际出现了 W"
```

### 陷阱 2：假设而非澄清

```
❌ Claude 猜测：这是一个持久化问题
✅ 你说：这是一个 demo，每次刷新都应该重置
```

### 陷阱 3：忽视 TypeScript 错误

```
❌ 修改代码后没有运行检查
✅ 修改后立即：npx tsc --noEmit
```

### 陷阱 4：修改过多后才测试

```
❌ 一次修改 10 个文件，然后测试
✅ 修改 1-2 个文件，测试，然后继续
```

### 陷阱 5：沉溺于理论优化

```
❌ 手动拖动逻辑虽然理论上更好，
   但实际体验比 Konva 原生拖动更差

✅ 快速失败：15 分钟尝试 → 效果不好 → 立即回退
```

### 陷阱 6：忘记提交代码

```
❌ 修改了很多文件，但忘记 git add & commit
✅ 每个功能完成后立即提交：
   git add .
   git commit -m "特性/修复：..."
```

---

## 📋 快速检查清单

每次与 Claude 协作时，检查以下几点：

### 描述问题时
- [ ] 是否清晰描述了问题现象？
- [ ] 是否说明了期望行为？
- [ ] 是否提供了重现步骤？
- [ ] 是否提及了相关文件？
- [ ] 是否说明了应用类型（demo/生产）？

### 修改代码后
- [ ] 是否运行了 TypeScript 检查？
- [ ] 是否在浏览器中测试了？
- [ ] 是否有新的错误出现？
- [ ] 是否提交了代码变更？

### 反馈修改质量时
- [ ] 是否指出了具体问题？
- [ ] 是否给出了改进建议？
- [ ] 是否与其他实现对比过？
- [ ] 是否允许 Claude 调整方案？

---

## 🎯 成功协作的关键指标

| 指标 | 目标 | 检查方法 |
|-----|------|---------|
| **问题诊断时间** | < 5 分钟 | Claude 多快就理解问题 |
| **修复实现时间** | < 15 分钟 | 代码写下来到能测试 |
| **反馈时间** | < 24 小时 | 不要让修改久久未验证 |
| **修改质量** | 首次成功率 > 80% | 修改后有多少需要调整 |
| **学习累积** | 每月新学 3-5 个概念 | 理解 Claude 和 React 的深度 |

---

## 🏁 最终提示

> **与 Claude Code 的协作本质是：清晰沟通 + 快速反馈 + 互相信任**

- **清晰沟通** → Claude 才能准确理解你的需求
- **快速反馈** → 加快迭代，不要让修改堆积
- **互相信任** → Claude 相信你的产品直觉，你相信 Claude 的技术能力

当这三点都做好时，你们的协作效率会超出想象。

---

## 🔗 相关资源

- [完整协作指南](../guides/CLAUDE_CODE_COLLABORATION_GUIDE.md)
- [快速参考速查表](../references/QUICK_REFERENCE.md)
- [5 个实战案例](../case-studies/)
